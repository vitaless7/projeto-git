## üìú Problema no Desenvolvimento

### Desafios com o Desenvolvimento Colaborativo

Em projetos de software, especialmente na √°rea de dados, √© comum termos v√°rias pessoas contribuindo ao mesmo tempo. Isso pode gerar conflitos de c√≥digo, perda de trabalho e dificuldades em gerenciar diferentes vers√µes de um mesmo arquivo. Antes do Git, essas situa√ß√µes frequentemente resultavam em erros e retrabalho, pois n√£o existia um controle eficiente sobre as mudan√ßas feitas no c√≥digo.

**Perguntas para Reflex√£o:**

- **Como voc√™s costumam compartilhar c√≥digo em equipe?** Ser√° que enviar arquivos por e-mail ou usar drives compartilhados √© a forma mais eficiente de colaborar?
- **Como garantir que todos os membros da equipe est√£o trabalhando na vers√£o mais atual do c√≥digo?** O que acontece quando diferentes pessoas fazem mudan√ßas no mesmo arquivo simultaneamente?
- **Qual seria o impacto de perder uma semana de trabalho por causa de um conflito de c√≥digo n√£o resolvido?** Como podemos prevenir a perda de progresso no desenvolvimento de software?
- **Como voc√™s organizam as diferentes vers√µes de um projeto?** Existe alguma estrat√©gia que voc√™s usam para controlar quais mudan√ßas foram feitas e por quem?
- **O que acontece quando queremos testar uma nova funcionalidade sem impactar o c√≥digo que j√° est√° funcionando?** Como isolar essas mudan√ßas para garantir que n√£o introduzimos novos bugs?

## üìÇ Vamos Criar um Projeto Simples

### 1. Cria√ß√£o de uma Pasta

Primeiro, vamos criar uma pasta para o nosso projeto:

```bash
mkdir projeto-git
cd projeto-git
```

### 2. Cria√ß√£o de um Arquivo Python

Dentro da pasta, vamos criar um arquivo Python simples:

```bash
touch main.py
```

Abra o arquivo `main.py` e adicione o seguinte c√≥digo:

```python
print("Hello, World!")
```

### Exemplo de Modifica√ß√µes Sem o Git

Vamos seguir o exemplo onde modificamos um arquivo Python v√°rias vezes e criamos novos arquivos, mas sem utilizar o Git para rastrear essas mudan√ßas. Isso demonstra o problema de n√£o ter controle de vers√£o e como √© f√°cil perder o hist√≥rico do que foi feito.

#### Passo 1: Criando e Modificando o Arquivo Inicial

Primeiro, criamos o arquivo `main.py` com o seguinte conte√∫do:

```python
print("Hello, World!")
```

Essa √© a primeira vers√£o do arquivo. Agora, imagine que voc√™ precisa fazer algumas mudan√ßas.

#### Passo 2: Primeira Modifica√ß√£o

Voc√™ modifica o arquivo `main.py` para adicionar uma nova linha de c√≥digo:

```python
print("Hello, World!")
print("Primeira Modifica√ß√£o")
```

Essa mudan√ßa √© feita diretamente no arquivo, substituindo a vers√£o anterior. Como n√£o estamos usando Git, a vers√£o original do arquivo √© perdida, e n√£o temos mais acesso a ela.

#### Passo 3: Segunda Modifica√ß√£o

Depois de algum tempo, voc√™ decide modificar o arquivo novamente:

```python
print("Hello, World!")
print("Primeira Modifica√ß√£o")
print("Segunda Modifica√ß√£o")
```

Mais uma vez, o arquivo original e a primeira modifica√ß√£o s√£o substitu√≠dos por essa nova vers√£o. Sem o Git, n√£o h√° registro das mudan√ßas anteriores.

#### Passo 4: Terceira Modifica√ß√£o e Cria√ß√£o de um Novo Arquivo

Agora, voc√™ faz uma terceira modifica√ß√£o no `main.py` e tamb√©m cria um novo arquivo chamado `auxiliary.py`:

**main.py:**

```python
print("Hello, World!")
print("Primeira Modifica√ß√£o")
print("Segunda Modifica√ß√£o")
print("Terceira Modifica√ß√£o")
```

**auxiliary.py:**

```python
def helper():
    print("Fun√ß√£o Auxiliar")
```

Essas novas mudan√ßas tamb√©m s√£o feitas diretamente no arquivo, substituindo tudo o que havia antes. Como n√£o estamos usando Git, o hist√≥rico das tr√™s vers√µes anteriores do `main.py` √© completamente perdido.

### O Problema Sem Git

Sem o Git, n√£o temos como recuperar o estado anterior do arquivo `main.py` em nenhum desses momentos. Se algo der errado, n√£o h√° como voltar para uma vers√£o anterior. Al√©m disso, se tivermos conflitos ou d√∫vidas sobre o que foi mudado ao longo do tempo, n√£o temos um hist√≥rico para consultar.

### Como o Git Resolveria Esse Problema

Se estiv√©ssemos usando Git, cada uma dessas modifica√ß√µes poderia ter sido feita em um novo commit. Isso significaria que, a qualquer momento, poder√≠amos voltar a uma vers√£o anterior do arquivo ou ver exatamente o que mudou entre os commits. Tamb√©m poder√≠amos criar branches para testar novas funcionalidades sem afetar o c√≥digo principal, garantindo que sempre tiv√©ssemos uma vers√£o est√°vel do projeto.

## üêß Hist√≥ria do Git

### Hist√≥ria do Git: A Palestra Famosa de Linus Torvalds

Git foi criado em 2005 por Linus Torvalds, o criador do Linux, em resposta √† necessidade de um sistema de controle de vers√£o robusto e eficiente para o desenvolvimento do kernel Linux. Na √©poca, o time de desenvolvimento enfrentava desafios significativos para gerenciar contribui√ß√µes de milhares de desenvolvedores ao redor do mundo. O Git foi concebido para ser r√°pido, distribu√≠do e capaz de lidar com a complexidade de projetos desse porte.

### A Famosa Palestra de Linus Torvalds

Em uma palestra bem conhecida, Linus Torvalds falou sobre a cria√ß√£o do Git e como ele o desenvolveu em apenas alguns dias. Com seu humor caracter√≠stico, ele mencionou que decidiu criar o Git durante um final de semana, ap√≥s ficar frustrado com as limita√ß√µes das ferramentas de controle de vers√£o existentes na √©poca.

Linus explicou que, ao criar o Git, ele focou em tr√™s principais caracter√≠sticas: velocidade, simplicidade no design e suporte para desenvolvimento distribu√≠do. Ele queria uma ferramenta que fosse f√°cil de usar para desenvolvedores de todo o mundo, permitindo que cada um tivesse uma c√≥pia completa do reposit√≥rio, sem a necessidade de um servidor central, e que fosse r√°pida o suficiente para lidar com as necessidades do kernel Linux.

Durante a palestra, Linus destacou a import√¢ncia da liberdade e do controle que o Git proporciona aos desenvolvedores, algo que faltava nas ferramentas anteriores. Ele tamb√©m brincou sobre o fato de que, embora tenha come√ßado o projeto em um final de semana, o Git rapidamente se tornou uma das ferramentas mais importantes e amplamente adotadas na hist√≥ria do desenvolvimento de software.

Essa hist√≥ria ilustra n√£o s√≥ a genialidade de Linus Torvalds, mas tamb√©m a urg√™ncia e a necessidade que existiam por uma solu√ß√£o como o Git. Desde ent√£o, o Git se tornou a ferramenta padr√£o para controle de vers√£o em quase todos os projetos de software no mundo.

Para entender mais sobre Git:
- [Sobre Git com Akita e Palestra de Linus Torvalds sobre Git](https://www.youtube.com/watch?v=6Czd1Yetaac)

## üõ†Ô∏è O Que √© o Git?

### Um Programa Como Qualquer Outro

Git √© um programa que voc√™ instala em seu computador, semelhante a como o PowerBI √© utilizado para criar dashboards. No caso do Git, ele √© usado para versionar arquivos de texto, como c√≥digo-fonte, de maneira eficiente. Isso permite que voc√™:

- **Versione Arquivos:** Mantenha um hist√≥rico detalhado de todas as mudan√ßas feitas em seus arquivos.
- **Colabore Facilmente:** Trabalhe com muitos contribuidores de forma organizada.
- **Distribua C√≥digo:** Compartilhe seu c√≥digo com outras pessoas, garantindo que todos estejam sincronizados com a vers√£o mais recente.

## üíª Como Instalar o Git

### Windows

1. Baixe o instalador do Git [aqui](https://git-scm.com/download/win).
2. Execute o instalador e siga as instru√ß√µes.

### Linux

1. Abra o terminal.
2. Execute o comando:
   
   ```bash
   sudo apt-get install git
   ```

### Mac

1. Abra o terminal.
2. Execute o comando:
   
   ```bash
   brew install git
   ```

## üéØ Configura√ß√£o do Git

Antes de come√ßar a usar o Git, precisamos configurar o nome e o e-mail do usu√°rio:

```bash
git config --global user.name "Seu Nome"
git config --global user.email "seu.email@exemplo.com"
```

Os arquivos de configura√ß√£o do Git que armazenam as configura√ß√µes feitas com os comandos `git config` s√£o armazenados em diferentes locais, dependendo do n√≠vel de configura√ß√£o:

1. **Configura√ß√µes Globais (`--global`)**:
   - As configura√ß√µes globais s√£o salvas no arquivo `.gitconfig` localizado no diret√≥rio home do usu√°rio.
   - **Localiza√ß√£o**:
     - **Linux/Mac**: `~/.gitconfig`
     - **Windows**: `C:\Users\SeuNomeDeUsuario\.gitconfig`
   - Voc√™ pode abrir esse arquivo em um editor de texto para visualizar ou editar as configura√ß√µes.

2. **Configura√ß√µes de Sistema (`--system`)**:
   - As configura√ß√µes de sistema s√£o aplicadas a todos os usu√°rios da m√°quina e s√£o armazenadas no arquivo de configura√ß√£o global do sistema.
   - **Localiza√ß√£o**:
     - **Linux**: `/etc/gitconfig`
     - **Windows**: Pode estar em um caminho como `C:\Program Files\Git\etc\gitconfig`
   - Essas configura√ß√µes requerem permiss√µes de administrador para serem alteradas.

3. **Configura√ß√µes Locais (por reposit√≥rio)**:
   - As configura√ß√µes locais s√£o espec√≠ficas para um √∫nico reposit√≥rio Git e s√£o salvas no arquivo `config` dentro da pasta `.git` do reposit√≥rio.
   - **Localiza√ß√£o**:
     - No diret√≥rio do reposit√≥rio Git: `.git/config`

Voc√™ pode visualizar as configura√ß√µes atuais usando os seguintes comandos:

- **Para ver todas as configura√ß√µes globais**:
  ```bash
  git config --global --list
  ```

Esses comandos v√£o listar as configura√ß√µes e seus valores, permitindo que voc√™ veja detalhes como o nome de usu√°rio e o e-mail configurados para o Git.

### Exemplo Completo Usando Git: Passo a Passo

Vamos seguir um exemplo onde fazemos modifica√ß√µes em um arquivo Python e gerenciamos essas altera√ß√µes usando Git. Este processo incluir√° a cria√ß√£o de commits para cada modifica√ß√£o, al√©m de explorar conceitos importantes como o `HEAD`, branches, e o comando `git checkout`.

### 1. Cria√ß√£o do Reposit√≥rio e Primeira Modifica√ß√£o

#### Inicializando o Reposit√≥rio

Primeiro, vamos inicializar um novo reposit√≥rio Git no diret√≥rio do projeto:

```bash
git init
```

Este comando cria um reposit√≥rio Git vazio, onde come√ßaremos a rastrear nossas altera√ß√µes.

#### Criando e Adicionando o Arquivo ao Controle de Vers√£o

Vamos criar um arquivo Python chamado `main.py`:

```bash
touch main.py
```

Abra o arquivo `main.py` e adicione o

 seguinte c√≥digo:

```python
print("Hello, World!")
```

Agora, vamos verificar o estado do reposit√≥rio para ver como o Git est√° reconhecendo o arquivo:

```bash
git status
```

Voc√™ ver√° que `main.py` est√° listado como um arquivo n√£o rastreado (untracked). Vamos adicionar esse arquivo ao Git para que ele comece a ser rastreado:

```bash
git add main.py
```

Agora, faremos o primeiro commit para salvar o estado inicial do projeto:

```bash
git commit -m "Adiciona o arquivo main.py com um simples print"
```

### 2. Primeira Modifica√ß√£o e Novo Commit

Agora, vamos modificar o arquivo `main.py`:

```python
print("Hello, World!")
print("Primeira Modifica√ß√£o")
```

Depois de fazer a modifica√ß√£o, vamos verificar novamente o estado dos arquivos:

```bash
git status
```

Agora observamos que temos duas op√ß√µes

```mermaid
graph TD;

A[Modified main.py in Working Directory] --> B{Choose an Option};

B --> |"git add main.py"| C[Staging Area];
C --> D["git commit -m 'Update main.py'"];
D --> E[New Commit Saved in Git Repository];

B --> |"git restore main.py"| F[Working Directory Restored to Last Commit];
F --> G["Restored from Git Repository"];

subgraph Git Repository
    E
    G
end
```

### Explica√ß√£o do Fluxo:

- **Op√ß√£o 1: `git add`**:
    - **`git add main.py`**: As mudan√ßas no `main.py` s√£o movidas para a Staging Area.
    - **`git commit -m 'Update main.py'`**: Um novo commit √© criado, e as mudan√ßas s√£o salvas na caixa do Git Repository.

- **Op√ß√£o 2: `git restore`**:
    - **`git restore main.py`**: O arquivo `main.py` no Working Directory √© restaurado a partir da √∫ltima vers√£o salva no Git Repository, descartando as mudan√ßas feitas localmente.

Esse diagrama ilustra claramente como as mudan√ßas fluem entre o Working Directory, a Staging Area, e o Git Repository, dependendo da a√ß√£o escolhida (`git add` ou `git restore`).

O Git mostrar√° que o arquivo `main.py` foi modificado. Vamos adicionar essa modifica√ß√£o √† √°rea de staging e fazer um novo commit:

### 2. Primeira Modifica√ß√£o e Novo Commit

```bash
git add main.py
```

### Git status

Ao realizar o Git status observamos que temos 2 op√ß√µes novamente

```mermaid
graph TD;

A[Modified main.py in Staging Area] --> B{Choose an Option};

B --> |"git commit -m 'Update main.py'"| C[New Commit Saved in Git Repository];
B --> |"git restore --staged main.py"| D[Unstaged, Returned to Working Directory];

subgraph Git Repository
    C
end

D --> E[main.py in Working Directory];
```

### Explica√ß√£o do Fluxo:

- **Op√ß√£o 1: `git commit`**:
    - **`git commit -m 'Update main.py'`**: Cria um novo commit no Git Repository, salvando as mudan√ßas que estavam na Staging Area.

- **Op√ß√£o 2: `git restore --staged`**:
    - **`git restore --staged main.py`**: Remove o arquivo `main.py` da Staging Area, retornando-o ao Working Directory sem as mudan√ßas serem cometidas. Ele volta ao estado antes de ser adicionado √† Staging Area.

Vamos seguir com o commit

### 2. Primeiro Save no Commit

```bash
git commit -m "Adiciona a primeira modifica√ß√£o ao arquivo main.py"
```

### Fluxo

```mermaid
graph TD;

subgraph Working Directory
    A[main.py Modified]
end

subgraph Staging Area
    B[main.py Staged]
end

subgraph Git Repository
    C[main.py Committed]
end

A --> |"git add"| B;
B --> |"git commit"| C;
C --> |"git restore"| A;
B --> |"git restore --staged"| A;
```

### 3. Segunda Modifica√ß√£o e Novo Commit

Vamos modificar o arquivo novamente:

```python
print("Hello, World!")
print("Primeira Modifica√ß√£o")
print("Segunda Modifica√ß√£o")
```

Novamente, adicionamos e fazemos um commit dessas mudan√ßas:

```bash
git add main.py
git commit -m "Adiciona a segunda modifica√ß√£o ao arquivo main.py"
```

### 4. Terceira Modifica√ß√£o e Novo Commit

Finalmente, vamos adicionar uma terceira modifica√ß√£o:

```python
print("Hello, World!")
print("Primeira Modifica√ß√£o")
print("Segunda Modifica√ß√£o")
print("Terceira Modifica√ß√£o")
```

E, novamente, fazemos o commit:

```bash
git add main.py
git commit -m "Adiciona a terceira modifica√ß√£o ao arquivo main.py"
```

### 5. Verificando o Hist√≥rico de Commits

Agora, podemos usar o `git log` para visualizar o hist√≥rico de commits e ver todas as modifica√ß√µes que fizemos at√© agora:

```bash
git log
```

O `git log` exibir√° uma lista de todos os commits, mostrando as mensagens e os identificadores √∫nicos (hashes) dos commits.

### 6. Entendendo o `HEAD`

O `HEAD` √© um apontador especial que indica o commit atual em que voc√™ est√° trabalhando. Normalmente, o `HEAD` aponta para a branch `main`, que √© a linha principal de desenvolvimento do projeto.

**Ilustra√ß√£o com Mermaid:**

```mermaid
graph TD;
    A[Commit Inicial] --> B[Primeira Modifica√ß√£o];
    B --> C[Segunda Modifica√ß√£o];
    C --> D[Terceira Modifica√ß√£o];
    E(HEAD -> main) --> D;
```

Aqui, o `HEAD` est√° apontando para o commit mais recente na branch `main`. Isso significa que todas as opera√ß√µes, como novos commits, partir√£o desse ponto.

### 7. Trabalhando com Branches

Branches s√£o como linhas do tempo paralelas no seu reposit√≥rio. Elas permitem que voc√™ trabalhe em diferentes funcionalidades ou corre√ß√µes de bugs sem afetar a `main`.

**Criando uma Nova Branch:**

Vamos criar uma nova branch chamada `nova-feature` para trabalhar em uma nova funcionalidade:

```bash
git branch nova-feature
```

Agora, podemos mudar para essa branch e come√ßar a trabalhar nela:

```bash
git checkout nova-feature
```

Isso muda o `HEAD` para a nova branch `nova-feature`, o que significa que qualquer commit feito agora ser√° registrado nessa branch.

**Ilustra√ß√£o com Mermaid:**

```mermaid
graph TD;
    A[Commit Inicial] --> B[Primeira Modifica√ß√£o];
    B --> C[Segunda Modifica√ß√£o];
    C --> D[Terceira Modifica√ß√£o];
    E(HEAD -> nova-feature) --> D;
    F(nova-feature) --> D;
    G(main) --> D;
```

Aqui, a `nova-feature` diverge da `main` a partir do mesmo ponto, permitindo que voc√™ desenvolva funcionalidades de forma isolada.

### 8. Usando `git checkout` para Navegar Entre Commits e Branches

O comando `git checkout` permite que voc√™ navegue entre diferentes branches e commits. Se voc√™ quiser voltar para a branch `main`, pode usar:

```bash
git checkout main
```

Se quiser explorar o estado do projeto em um commit anterior, use:

```bash
git checkout <hash_do_commit>
```

Isso coloca voc√™ em um estado de "detached HEAD", onde voc√™ pode ver o estado do projeto naquele momento espec√≠fico.

### 9. Usando `git reset` para Voltar ao Commit Anterior

Se voc√™ deseja desfazer as √∫ltimas mudan√ßas e voltar ao estado de um commit anterior, pode usar o `git reset`. Aqui est√£o as op√ß√µes:

- **`git reset --soft <idCommit>`**: Volta para o commit anterior e mant√©m todas as altera√ß√µes na √°rea de staging.

- **`git reset --mixed <idCommit>`**: Volta para o commit anterior, remove as altera√ß√µes da √°rea de staging, mas as mant√©m no diret√≥rio de trabalho.

- **`git reset --hard <idCommit>`**: Volta para o commit anterior e descarta completamente todas as altera√ß√µes feitas ap√≥s esse commit.

**Ilustra√ß√£o com Mermaid:**

```mermaid
graph TD;
    A[Commit Inicial] --> B[Primeira Modifica√ß√£o];
    B --> C[Segunda Modifica√ß√£o];
    C --> D[Terceira Modifica√ß√£o];
    E(HEAD -> nova-feature) --> D;
    F(nova-feature) --> D;
    G(main) --> D;
    H[Reset --hard] --> B;
```

Aqui, o comando `git reset --hard` move o `HEAD` de volta para a "Primeira Modifica√ß√£o", descartando todas as altera√ß√µes feitas ap√≥s esse ponto.

### 10. Criando uma Branch a Partir de um Commit Anterior

Se voc√™ quer preservar o estado atual do projeto, mas precisa voltar a um commit anterior para experimentar algo novo, pode criar uma nova branch a partir desse commit:

```bash
git checkout -b experiment <hash_do_commit>
```

Isso cria uma nova branch chamada `experiment`, come√ßando a partir do commit que voc√™ especificou.

**Ilustra√ß√£o com Mermaid:**

```mermaid
graph TD;
    A[Commit Inicial] --> B[Primeira Modifica√ß√£o];
    B --> C[Segunda Modifica√ß√£o];
    C --> D[Terceira Modifica√ß√£o];
    E(HEAD -> experiment) --> B;
    F(main) --> D;
```

### Caso real

Vamos expandir o exemplo para incluir tr√™s branches diferentes, cada uma com uma modifica√ß√£o espec√≠fica em um arquivo, e um branch `main` que representa o c√≥digo em produ√ß√£o. Vou descrever a situa√ß√£o e depois mostrar o diagrama em Mermaid.

### Situa√ß√£o:

1. **Branch `main`**: Cont√©m o c√≥digo de produ√ß√£o, sem as novas funcionalidades que estamos desenvolvendo.
2. **Branch `feature-1`**: Modifica o `file1.py` para adicionar uma nova funcionalidade.
3. **Branch `feature-2`**: Modifica o `file2.py` para adicionar outra funcionalidade.
4. **Branch `feature-3`**: Modifica o `file3.py` para adicionar uma terceira funcionalidade.

### Passos:

1. **Criar e mudar para a branch `feature-1`**:
    ```bash
    git branch feature-1
    git checkout feature-1
    # Modificar file1.py e fazer commit
    git commit -am "Adiciona nova funcionalidade em file1.py"
    ```

2. **Criar e mudar para a branch `feature-2`**:
    ```bash
    git branch feature-2
    git checkout feature-2
    # Modificar file2.py e fazer commit
    git commit -am "Adiciona nova funcionalidade em file2.py"
    ```

3. **Criar e mudar para a branch `feature-3`**:
    ```bash
    git branch feature-3
    git checkout feature-3
    # Modificar file3.py e fazer commit
    git commit -am "Adiciona nova funcionalidade em file3.py"
    ```

### Diagrama Mermaid:

Aqui est√° o diagrama que ilustra essas opera√ß√µes:

```mermaid
graph TD;
    subgraph main [Branch: main Production]
        A[Initial Commit] --> B[Main Codebase];
    end

    subgraph feature-1 [Branch: feature-1]
        B --> C[Commit: Modifica file1.py];
    end

    subgraph feature-2 [Branch: feature-2]
        B --> D[Commit: Modifica file2.py];
    end

    subgraph feature-3 [Branch: feature-3]
        B --> E[Commit: Modifica file3.py];
    end

    A --- B;
    C --> G[feature-1];
    D --> H[feature-2];
    E --> I[feature-3];

    style B fill:#f9f,stroke:#333,stroke-width:4px;
    style C fill:#bbf,stroke:#333,stroke-width:2px;
    style D fill:#bfb,stroke:#333,stroke-width:2px;
    style E fill:#fbf,stroke:#333,stroke-width:2px;
```

### Explica√ß√£o do Diagrama:

- **Branch `main`**: Representa o c√≥digo em produ√ß√£o, onde n√£o foram aplicadas as novas funcionalidades.
- **Branch `feature-1`**: Diverge do `main` ap√≥s o commit inicial e inclui uma modifica√ß√£o em `file1.py`.
- **Branch `feature-2`**: Diverge do `main` ap√≥s o commit inicial e inclui uma modifica√ß√£o em `file2.py`.
- **Branch `feature-3`**: Diverge do `main` ap√≥s o commit inicial e inclui uma modifica√ß√£o em `file3.py`.

Cada branch permite que voc√™ trabalhe em funcionalidades diferentes de forma isolada. Os commits em cada branch representam o trabalho feito nessas funcionalidades. Quando as funcionalidades estiverem prontas e testadas, voc√™ poder√° mesclar (`merge`) essas branches de volta ao `main` para que as novas funcionalidades sejam incorporadas ao c√≥digo de produ√ß√£o.

Vamos continuar o exemplo, adicionando os comandos para mesclar as branches de funcionalidades (`feature-1`, `feature-2`, `feature-3`) de volta ao `main` quando as funcionalidades estiverem prontas.

### Situa√ß√£o Revisada:

1. **Branch `main`**: Cont√©m o c√≥digo de produ√ß√£o.
2. **Branch `feature-1`**: Modifica o `file1.py` para adicionar uma nova funcionalidade.
3. **Branch `feature-2`**: Modifica o `file2.py` para adicionar outra funcionalidade.
4. **Branch `feature-3`**: Modifica o `file3.py` para adicionar uma terceira funcionalidade.

### Passos Revisados:

1. **Criar e mudar para a branch `feature-1`**:
    ```bash
    git branch feature-1
    git checkout feature-1
    # Modificar file1.py e fazer commit
    git commit -am "Adiciona nova funcionalidade em file1.py"
    ```

2. **Criar e mudar para a branch `feature-2`**:
    ```bash
    git branch feature-2
    git checkout feature-2
    # Modificar file2.py e fazer commit
    git commit -am "Adiciona nova funcionalidade em file2.py"
    ```

3. **Criar e mudar para a branch `feature-3`**:
    ```bash
    git branch feature-3
    git checkout feature-3
    # Modificar file3.py e fazer commit
    git commit -am "Adiciona nova funcionalidade em file3.py"
    ```

### Mesclando as Branches de Funcionalidade no `main`:

Depois que cada funcionalidade estiver pronta, voc√™ pode mesclar essas branches de volta ao `main`. Aqui est√£o os passos:

1. **Mesclar `feature-1` no `main`**:
    ```bash
    git checkout main
    git merge feature-1
    ```

2. **Mesclar `feature-2` no `main`**:
    ```bash
    git checkout main
    git merge feature-2
    ```

3. **Mesclar `feature-3` no `main`**:
    ```bash
    git checkout main
    git merge feature-3
    ```

### Diagrama Mermaid Atualizado:

Aqui est√° o diagrama que ilustra essas opera√ß√µes, incluindo as etapas de merge:

```mermaid
graph TD;
    subgraph main [Branch: main Production]
        A[Initial Commit] --> B[Main Codebase];
        F[Merge feature-1] --> G[Merge feature-2];
        G --> H[Merge feature-3];
    end

    subgraph feature-1 [Branch: feature-1]
        B --> C[Commit: Modifica file1.py];
    end

    subgraph feature-2 [Branch: feature-2]
        B --> D[Commit: Modifica file2.py];
    end

    subgraph feature-3 [Branch: feature-3]
        B --> E[Commit: Modifica file3.py];
    end

    C --> F;
    D --> G;
    E --> H;
```

### Explica√ß√£o do Diagrama Atualizado:

- **Branch `main`**: Representa o c√≥digo de produ√ß√£o. Inicialmente, cont√©m apenas o commit inicial e o c√≥digo base.
- **Branches de Funcionalidade**:
  - **`feature-1`**: Cont√©m a modifica√ß√£o em `file1.py`.
  - **`feature-2`**: Cont√©m a modifica√ß√£o em `file2.py`.
  - **`feature-3`**: Cont√©m a modifica√ß√£o em `file3.py`.
- **Mesclagens (`Merges`)**:
  - Cada branch de funcionalidade √© mesclada de volta ao `main`, integrando as novas funcionalidades no c√≥digo de produ√ß√£o.

### Comandos de Merge:

- **Mesclar `feature-1` no `main`**:
  ```bash
  git checkout main
  git merge feature-1
  ```

- **Mesclar `feature-2` no `main`**:
  ```bash
  git checkout main
  git merge feature-2
  ```

- **Mesclar `feature-3` no `main`**:
  ```bash
  git checkout main
  git merge feature-3
  ```

### Conclus√£o:

Esse fluxo permite que cada funcionalidade seja desenvolvida em isolamento, testada individualmente e, quando pronta, integrada ao c√≥digo de produ√ß√£o sem afetar o `main` at√© que tudo esteja pronto. Isso torna o processo de desenvolvimento mais seguro e organizado, minimizando conflitos e problemas na integra√ß√£o das funcionalidades.

### O que vamos ver amanh√£:

Amanh√£, vamos explorar em detalhes o conceito de **Remote Repository** no Git. At√© agora, vimos como o **Working Directory**, a **Staging Area**, e o **Local Git Repository** trabalham juntos na sua m√°quina local para gerenciar as mudan√ßas no seu projeto.

Agora, vamos entender como o **Remote Repository** se encaixa nesse fluxo. O **Remote Repository** √© uma vers√£o do seu reposit√≥rio que fica armazenada em um servidor remoto, como o GitHub, GitLab ou Bitbucket. Ele permite que voc√™:

- **Compartilhe C√≥digo com Outros Desenvolvedores**: Enviar (push) seus commits para um reposit√≥rio remoto permite que outros desenvolvedores acessem e colaborem no seu projeto.
- **Mantenha um Backup Externo**: Ter uma c√≥pia do seu reposit√≥rio em um servidor remoto fornece uma camada extra de seguran√ßa para o seu trabalho.
- **Colabore de Forma Eficiente**: Usar um reposit√≥rio remoto facilita a colabora√ß√£o entre times, onde cada membro pode clonar, puxar (pull) e enviar mudan√ßas para o reposit√≥rio compartilhado.

No diagrama que revisamos, o **Remote Repository** √© representado como o destino para onde voc√™ envia as mudan√ßas feitas no **Local Git Repository**. Amanh√£, veremos como configurar e trabalhar com reposit√≥rios remotos, incluindo comandos essenciais como `git push`, `git pull`, e `git clone`, para que voc√™ possa colaborar efetivamente em projetos de dados com outras pessoas.

```mermaid
graph TD;

A[Working Directory] --> |"git add"| B[Staging Area];
B --> |"git commit"| C[Commit];
C --> |"Stored in"| D[Local Git Repository];

subgraph Local Machine
    A
    B
    C
    D
end

D --> |"git push"| E[Remote Repository];
```